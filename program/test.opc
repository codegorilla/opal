
// Fset = $ IMPORT USE, etc.

package main;

//fuse ; opal.lang.*;

//use opal.lang.{ Math, Util };
//use opal.lang.*;

//import std.math. .+link as;

//package 5 8 5 improt tom.main+;

//var t: int = 0;

//import std-;

// This should print an error, but doesn't. If I move the other import to
// the same line, then it prints an error. Why is there a difference in
// behavior, since newlines should be thrown out by the lexer?
// Oh, it is catching it, but its printing the second line as the source line!
// Maybe we need special handling for semicolons.

//import opal.math;

//import opal-lang.+;

//imprt math.phi;

//use math.lang;

/*
import lang.math;
import opal.grinch as math;
import opal.math as math;
import std.crypto;
import std.str;

use opal.lang.math.{ Bessel, Jacobian };
use lang.math.cos;
use lang.math.*;

typealias IntPtr = *int[10];

private def myfun1 (s: float, t: uint32) -> *int {
  var x: int = 0;
}

private var b: int = 0.5;

final class Token extends Object, Number {

  static var x: int = 1;

  typealias FloatPtr = *float;

  private static def getLexeme () const -> String {
    var a: int = 0;
  }

  private virtual final def getLexeme1 () const {
    var a: int = 0;
  }

  virtual abstract override def getToken (x: IntPtr) const & -> *int {
    typealias IntPtr = *int;
    var b: int = 0;
  }

}

def test () {
  typealias IntPtr = *int;
  var c: int = 0;
}
*/
